# Advanced Data Structures & Algorithms (ADSA) Lab Work

##### MTech CSE, IIIT Bhubaneshwar

---

## ğŸš€ Overview

Welcome to my **ADSA Lab Work** repository! This repository contains all my implementations, experiments, and analysis of advanced data structures and algorithms. The primary goal of these lab exercises is to:

* Understand **complex data structures** like heaps, trees, graphs, and more
* Implement **classical and modern algorithms** efficiently
* Compare **time and space complexities** for different approaches
* Apply theoretical concepts to **practical programming problems**

These exercises enhance problem-solving skills, algorithmic thinking, and prepare for real-world scenarios involving **large-scale data and optimization**.

---

## ğŸ—‚ Repository Structure

The repository is organized by **topics and lab exercises**. Each folder contains the source code, input/output examples, and README files explaining the problem.

| Topic                                 | Description                                                                                                                  |
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| **Stacks & Queues**                   | Implementation of stack-based problems, infix-to-postfix conversion, postfix evaluation                                      |
| **Trees**                             | AVL Tree, B-Tree, Splay Tree, Binary Search Tree operations                                                                  |
| **Graphs**                            | Graph representations, BFS, DFS, shortest path algorithms (Dijkstra, Floyd-Warshall), Minimum Spanning Trees (Kruskal, Prim) |
| **Heaps**                             | Binary Heap, Fibonacci Heap, Heap Sort                                                                                       |
| **String Algorithms**                 | Knuth-Morris-Pratt (KMP), Rabin-Karp, Longest Common Subsequence                                                             |
| **Matrix & Linear Algebra**           | LU decomposition, LUP solver, Strassenâ€™s matrix multiplication                                                               |
| **Optimization & Linear Programming** | Simplex Method, Interior Point Method, Ellipsoid Algorithm                                                                   |
| **Other Algorithms**                  | Coin weighing problem, search algorithms (binary/ternary search), greedy and dynamic programming exercises                   |

---

## ğŸ’¡ Key Features

* **Algorithm Implementation:** Each lab problem includes a **C language implementation** or pseudo-code for clarity.
* **Step-by-Step Explanation:** README files for each lab include **algorithm description, complexity analysis, and examples**.
* **Performance Comparison:** For applicable problems, algorithms are **benchmarked** to show time and space efficiency.
* **Visualization & Tables:** Many topics include **tables, graphs, and diagrams** for better understanding of the algorithms.

---

## âš¡ Highlights of the Lab Work

### 1. Data Structures

* **AVL Tree & B-Tree:** Efficient insert, delete, and traversal operations
* **Splay Tree:** Self-adjusting tree operations and amortized analysis
* **Heaps:** Binary and Fibonacci heaps for priority queue applications

### 2. Graph Algorithms

* **Single-source & all-pairs shortest paths**
* **Minimum Spanning Tree:** Kruskalâ€™s and Primâ€™s algorithms
* **Graph generation** from SIF (Simple Interaction Format)

### 3. String & Searching

* **Pattern matching algorithms:** KMP, Rabin-Karp
* **Longest common subsequence and all subsequences**
* **Binary and Ternary Search:** Time complexity comparison

### 4. Linear Algebra & Optimization

* **Matrix operations:** LU decomposition, LUP solver, Strassenâ€™s multiplication
* **Linear programming:** Simplex, Interior Point, and Ellipsoid methods
* **Algorithmic optimization exercises:** Coin weighing, greedy, and dynamic programming problems

---

## ğŸ“Š Complexity Analysis

For each lab problem, I have analyzed:

| Algorithm/Problem | Time Complexity        | Space Complexity | Notes                          |
| ----------------- | ---------------------- | ---------------- | ------------------------------ |
| Binary Search     | O(log n)               | O(1)             | Efficient for sorted arrays    |
| Ternary Search    | O(logâ‚ƒ n)              | O(1)             | More comparisons per iteration |
| Heap Sort         | O(n log n)             | O(1)             | In-place sorting               |
| Kruskal MST       | O(E log E)             | O(V)             | Efficient for sparse graphs    |
| Dijkstra          | O(VÂ²) / O(E + V log V) | O(V)             | Single-source shortest path    |

> Detailed analysis is provided in the respective lab folders with examples.

---

## ğŸ“ˆ Benchmarks & Observations

* **Heap vs Quick Sort:** Heap sort guarantees O(n log n) performance, but Quick Sort may be faster in practice for small datasets.
* **Binary vs Ternary Search:** Binary search often outperforms ternary search in discrete arrays due to fewer comparisons.
* **Graph Algorithms:** Dijkstra is optimal for sparse graphs, while Floyd-Warshall is suitable for dense graphs.

All performance results are measured with **clock-based timing functions in C**.

---

## ğŸ¯ Learning Outcomes

By completing these labs, I achieved:

* Mastery of advanced **data structures**: Trees, Graphs, Heaps
* Understanding of **algorithm design paradigms**: Divide & conquer, greedy, dynamic programming
* Experience in **time and space complexity analysis**
* Ability to **implement mathematical and optimization algorithms** in code
* Skill in **benchmarking and comparing algorithmic efficiency**

---

## ğŸŒŸ Future Enhancements

* Include **visualizations** for tree and graph operations using Python/JavaScript
* Add **interactive notebooks** for simulation and performance analysis
* Implement **parallelized versions** of certain algorithms for performance benchmarking

---

## ğŸ“‚ Contribution

This repository is a **personal lab work collection**, but contributions are welcome if you want to:

* Add more advanced data structures
* Optimize existing implementations
* Provide better explanations, diagrams, or benchmarks

---

## ğŸ“– References

* â€œIntroduction to Algorithmsâ€ â€” Cormen, Leiserson, Rivest, Stein
* â€œData Structures & Algorithm Analysis in Câ€ â€” Mark Allen Weiss
* Research papers and lecture notes on **optimization and linear programming**

---

## âœ¨ Summary

This repository is a **comprehensive showcase of Advanced Data Structures and Algorithms lab work**, covering everything from **classic data structures to advanced optimization algorithms**. Itâ€™s designed for **learning, reference, and performance analysis**, and can serve as a **resource for students and programmers** preparing for complex problem-solving and coding challenges.

---
